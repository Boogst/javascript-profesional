{"version":3,"sources":["sw.js"],"names":["VERSION","self","addEventListener","event","waitUntil","precache","request","method","respondWith","cachedResponse","updateCache","cache","caches","open","addAll","response","match","fetch","put"],"mappings":"AAAA,MAAMA,OAAO,GAAG,IAAhB,EAGA;;AACAC,IAAI,CAACC,gBAAL,CAAsB,SAAtB,EAAiCC,KAAK,IAAI;AAE9B;AACRA,EAAAA,KAAK,CAACC,SAAN,CAAgBC,QAAQ,EAAxB;AAGH,CAND,GAQA;AACA;;AACAJ,IAAI,CAACC,gBAAL,CAAsB,OAAtB,EAA+BC,KAAK,IAAG;AACnC,QAAMG,OAAO,GAAGH,KAAK,CAACG,OAAtB,CADmC,CAEnC;AACA;;AACA,MAAGA,OAAO,CAACC,MAAR,KAAmB,KAAtB,EAA4B;AACxB;AACH,GANkC,CAQnC;;;AACAJ,EAAAA,KAAK,CAACK,WAAN,CAAkBC,cAAc,CAACH,OAAD,CAAhC,EATmC,CAWnC;;AACAH,EAAAA,KAAK,CAACC,SAAN,CAAgBM,WAAW,CAACJ,OAAD,CAA3B;AACH,CAbD;;AAeA,eAAeD,QAAf,GAAyB;AACrB;AACA,QAAMM,KAAK,GAAG,MAAMC,MAAM,CAACC,IAAP,CAAYb,OAAZ,CAApB,CAFqB,CAEoB;;AACzC,SAAOW,KAAK,CAACG,MAAN,CAAa,CAChB,GADgB,EAEhB,aAFgB,EAGhB,kBAHgB,EAIhB,wBAJgB,EAKhB,6BALgB,EAMhB,8BANgB,EAOhB,mBAPgB,EAQhB,0BARgB,CAAb,CAAP;AAUH;;AAED,eAAeL,cAAf,CAA8BH,OAA9B,EAAsC;AAClC,QAAMK,KAAK,GAAG,MAAMC,MAAM,CAACC,IAAP,CAAYb,OAAZ,CAApB,CADkC,CAGlC;;AACA,QAAMe,QAAQ,GAAG,MAAMJ,KAAK,CAACK,KAAN,CAAYV,OAAZ,CAAvB;AACA,SAAOS,QAAQ,IAAIE,KAAK,CAACX,OAAD,CAAxB;AACH;;AAED,eAAeI,WAAf,CAA2BJ,OAA3B,EAAoC;AAChC,QAAMK,KAAK,GAAG,MAAMC,MAAM,CAACC,IAAP,CAAYb,OAAZ,CAApB;AACA,QAAMe,QAAQ,GAAG,MAAME,KAAK,CAACX,OAAD,CAA5B;AACA,SAAOK,KAAK,CAACO,GAAN,CAAUZ,OAAV,EAAmBS,QAAnB,CAAP;AACD","file":"sw.js","sourceRoot":"..","sourcesContent":["const VERSION = 'v1';\n\n\n// self es como el this, pero especifico para los serviceWorker\nself.addEventListener('install', event => {\n\n            //Espera al que el pre-cache se complete\n    event.waitUntil(precache())\n\n\n})\n\n//en v1 vamos a tener todos los assets que declaramos, eso sera nuestras peticiones. \n// Cuando occura una peticion queremos ir al cache para ver si encontramos una respuesta\nself.addEventListener('fetch', event =>{\n    const request = event.request\n    // get: Solo queremos hacer algo con las peticiones que son get, los post, put los delete no queremos trabajar con ellos.\n    // Usualmente traen datos que no queremos cachear \n    if(request.method !== 'GET'){\n        return;\n    }\n\n    // Buscar en cache\n    event.respondWith(cachedResponse(request));\n\n    //Actualizar el cache\n    event.waitUntil(updateCache(request));\n})\n\nasync function precache(){\n    //Para trabajar con cache tenemos que utilizar una API del dom, que se llama caches \n    const cache = await caches.open(VERSION) // Esto nos va a dar una instancia de un cache, se va a llamar v1. Pero esto regresa una promesa\n    return cache.addAll([\n        '/',\n        '/index.html',\n        '/assets/index.js',\n        '/assets/MediaPlayer.js',\n        '/assets/plugins/AutoPlay.js',\n        '/assets/plugins/AutoPause.js',\n        '/assets/index.css',\n        '/assets/BigBuckBunny.mp4',\n      ]);\n}\n\nasync function cachedResponse(request){\n    const cache = await caches.open(VERSION)\n        \n    //.match Estamos preguntando al cache ya tienes una copia que le corresponde al request, si o no?. Si es no, nos va regresar undefine\n    const response = await cache.match(request)\n    return response || fetch(request)\n}\n\nasync function updateCache(request) {\n    const cache = await caches.open(VERSION);\n    const response = await fetch(request);\n    return cache.put(request, response);\n  }\n\n"]}